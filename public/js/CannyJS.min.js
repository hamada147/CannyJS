/*********************************************************
 * CannyEdgeDetectionJS v 1.0
 * Developed By:- Ahmed Moussa <moussa.ahmed95@gmail.com>
 * Copyright (c) 2018 Ahmed Moussa. All rights reserved.
 * License:-
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any non commercial purpose and to alter it and redistribute it freely, subject to the following restrictions:
 * - The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation is required.
 * - Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * - This notice may not be removed or altered from any source or binary distribution.
 * - Redistributions of any form whatsoever must retain the following acknowledgment: 'This product includes software developed by the "Ahmed Moussa" <moussa.ahmed95@gmail.com>.'
 ********************************************************/
class Util{static generateMatrix(t,e,a){let i=[];for(let r=0,h=t-1;r<=h;r++){i[r]=[];for(let t=0,h=e-1;t<=h;t++)i[r][t]=a}return i}}class GrayImageData{setData(t){this.data=t}constructor(t,e){this.width=t,this.height=e,this.data=Util.generateMatrix(this.width,this.height,0)}loadCanvasFromData(t){let e=0,a=0;for(let i=0,r=t.length;i<r;i+=4){let r=t[i],h=t[i+1],l=t[i+2];this.data[e][a]=Math.round(.298*r+.586*h+.114*l),e===this.width-1?(e=0,a+=1):e+=1}}loadCanvas(t){let e=t.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,t.width,t.height,{willReadFrequently:!0}).data,a=0,i=0;for(let t=0,r=e.length;t<r;t+=4){let r=e[t],h=e[t+1],l=e[t+2];this.data[a][i]=Math.round(.298*r+.586*h+.114*l),a===this.width-1?(a=0,i+=1):a+=1}}getNeighbors(t,e,a){let i=Util.generateMatrix(a,a,0);for(let r=0,h=a-1;r<=h;r++){i[r]=[];for(let l=0;l<=h;l++){let h=t-(a-1)/2+r,s=e-(a-1)/2+l;this.data[h]&&this.data[h][s]?i[r][l]=this.data[h][s]:i[r][l]=0}}return i}eachPixel(t,e){for(let a=0,i=this.width-1;a<=i;a++)for(let i=0,r=this.height-1;i<=r;i++){e(a,i,this.data[a][i],this.getNeighbors(a,i,t))}}toImageDataArray(){let t=[];for(let e=0,a=this.height-1;e<=a;e++)for(let a=0,i=this.width-1;a<=i;a++){for(let i=0;i<=2;i++)t.push(this.data[a][e]);t.push(255)}return t}copy(){let t=new GrayImageData(this.width,this.height);for(let e=0,a=this.width-1;e<=a;e++)for(let a=0,i=this.height-1;a<=i;a++)t.data[e][a]=this.data[e][a];return t.width=this.width,t.height=this.height,t}drawOn(t){let e=t.getContext("2d",{willReadFrequently:!0}),a=e.createImageData(t.width,t.height),i=this.toImageDataArray();for(let t=0,e=i.length;t<e;t++)a.data[t]=i[t];e.putImageData(a,0,0)}fill(t){for(let e=0,a=this.height-1;e<=a;e++)for(let a=0,i=this.width-1;a<=i;a++)this.data[a][e]=t}}class CannyEdgeDetection{gaussianBlur(t,e=1.4,a=3){let i=this.generateKernel(e,a),r=t.copy();return r.fill(0),t.eachPixel(a,(function(t,e,h,l){let s=0,n=a-1;for(;s<=n;){let a=0;for(;a<=n;)r.data[t][e]+=l[s][a]*i[s][a],a++;s++}})),r}generateKernel(t,e){let a=t,i=Util.generateMatrix(e,e,0),r=0;for(let t=0,h=e-1;t<h;t++){let l=-(e-1)/2+t;for(let s=0;s<h;s++){let h=-(e-1)/2+s,n=1/(2*Math.PI*a*a)*Math.pow(2.718,-(l*l+h*h)/(2*a*a));i[t][s]=n,r+=n}}for(let t=0,a=e-1;t<a;t++)for(let e=0;e<a;e++)i[t][e]=(i[t][e]/r).toFixed(3);return i}sobel(t){let e=[[-1,0,1],[-2,0,2],[-1,0,1]],a=[[-1,-2,-1],[0,0,0],[1,2,1]],i=t.copy();return i.fill(0),t.eachPixel(3,(function(t,r,h,l){let s=0,n=0;for(let t=0;t<=2;t++)for(let i=0;i<=2;i++)s+=e[t][i]*l[t][i],n+=a[t][i]*l[t][i];i.data[t][r]=Math.sqrt(s*s+n*n)})),i}nonMaximumSuppression(t){let e=t.copy();return e.fill(0),t.eachPixel(3,(function(t,a,i,r){return r[1][1]>r[0][1]&&r[1][1]>r[2][1]?e.data[t][a]=r[1][1]:e.data[t][a]=0,r[1][1]>r[0][2]&&r[1][1]>r[2][0]?e.data[t][a]=r[1][1]:e.data[t][a]=0,r[1][1]>r[1][0]&&r[1][1]>r[1][2]?e.data[t][a]=r[1][1]:e.data[t][a]=0,r[1][1]>r[0][0]&&r[1][1]>r[2][2]?e.data[t][a]=r[1][1]:e.data[t][a]=0})),e}hysteresis(t,e,a){let i=t.copy(),r=function(t){return t>e},h=function(t){return t<=e&&t>=a};t.eachPixel(3,(function(t,e,l,s){return r(l)?i.data[t][e]=255:l<a||h(l)?i.data[t][e]=0:void 0}));let l=function(e,a){if(0!==e&&0!==a&&e!==t.width-1&&a!==t.height-1&&r(i.data[e][a])){let t=i.getNeighbors(e,a,3);for(let r=0;r<=2;r++)for(let s=0;s<=2;s++)h(t[r][s])&&(i.data[e-1+r][a-1+s]=255,l(e-1+r,a-1+s))}};return i.eachPixel(3,(function(t,e){return l(t,e)})),i.eachPixel(1,(function(t,e,a){if(!r(a))return i.data[t][e]=0})),i}canny(t,e,a,i,r){let h=new GrayImageData(t.width,t.height);h.loadCanvas(t);let l=this.gaussianBlur(h,i,r),s=this.sobel(l),n=this.nonMaximumSuppression(s);return this.hysteresis(n,e,a)}cannyWorker(t,e,a,i,r,h,l){let s=new GrayImageData(t,e);s.loadCanvasFromData(a);let n=this.gaussianBlur(s,h,l),o=this.sobel(n),d=this.nonMaximumSuppression(o);return this.hysteresis(d,i,r)}}
