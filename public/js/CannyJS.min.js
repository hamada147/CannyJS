/*********************************************************
 * CannyEdgeDetectionJS v 1.0
 * Developed By:- Ahmed Moussa <moussa.ahmed95@gmail.com>
 * Copyright (c) 2018 Ahmed Moussa. All rights reserved.
 * License:-
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any non commercial purpose and to alter it and redistribute it freely, subject to the following restrictions:
 * - The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation is required.
 * - Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * - This notice may not be removed or altered from any source or binary distribution.
 * - Redistributions of any form whatsoever must retain the following acknowledgment: 'This product includes software developed by the "Ahmed Moussa" <moussa.ahmed95@gmail.com>.'
 ********************************************************/
class Util{static generateMatrix(w,h,initialValue){let matrix=[];for(let x=0,_w=w-1;x<=_w;x++){matrix[x]=[];for(let y=0,_h=h-1;y<=_h;y++){matrix[x][y]=initialValue}}
return matrix}}
class GrayImageData{setData(data){this.data=data}
constructor(width,height){this.width=width;this.height=height;this.data=Util.generateMatrix(this.width,this.height,0)}
loadCanvasFromData(rawdata){let x=0;let y=0;for(let i=0,_len=rawdata.length;i<_len;i+=4){let r=rawdata[i];let g=rawdata[i+1];let b=rawdata[i+2];this.data[x][y]=Math.round((0.298*r)+(0.586*g)+(0.114*b));if(x===(this.width-1)){x=0;y+=1}else{x+=1}}}
loadCanvas(canvas){let ctx=canvas.getContext('2d');let rawdata=ctx.getImageData(0,0,canvas.width,canvas.height).data;let x=0;let y=0;for(let i=0,_len=rawdata.length;i<_len;i+=4){let r=rawdata[i];let g=rawdata[i+1];let b=rawdata[i+2];this.data[x][y]=Math.round((0.298*r)+(0.586*g)+(0.114*b));if(x===(this.width-1)){x=0;y+=1}else{x+=1}}}
getNeighbors(x,y,size){let neighbors=Util.generateMatrix(size,size,0);for(let i=0,_size1=size-1;i<=_size1;i++){neighbors[i]=[];for(let j=0;j<=_size1;j++){let trnsX=x-(size-1)/2+i;let trnsY=y-(size-1)/2+j;if(this.data[trnsX]&&this.data[trnsX][trnsY]){neighbors[i][j]=this.data[trnsX][trnsY]}else{neighbors[i][j]=0}}}
return neighbors}
eachPixel(neighborSize,func){for(let x=0,_w=this.width-1;x<=_w;x++){for(let y=0,_y=this.height-1;y<=_y;y++){let current=this.data[x][y];let neighbors=this.getNeighbors(x,y,neighborSize);func(x,y,current,neighbors)}}}
toImageDataArray(){let ary=[];for(let y=0,_h=this.height-1;y<=_h;y++){for(let x=0,_w=this.width-1;x<=_w;x++){for(let i=0;i<=2;i++){ary.push(this.data[x][y])}
ary.push(255)}}
return ary}
copy(){let copied=new GrayImageData(this.width,this.height);for(let x=0,_w=this.width-1;x<=_w;x++){for(let y=0,_h=this.height-1;y<=_h;y++){copied.data[x][y]=this.data[x][y]}}
copied.width=this.width;copied.height=this.height;return copied}
drawOn(canvas){let ctx=canvas.getContext('2d');let imgData=ctx.createImageData(canvas.width,canvas.height);let colors=this.toImageDataArray();for(let i=0,_len=colors.length;i<_len;i++){let color=colors[i];imgData.data[i]=color}
ctx.putImageData(imgData,0,0)}
fill(color){let start=new Date;for(let y=0,_h=this.height-1;y<=_h;y++){for(let x=0,_w=this.width-1;x<=_w;x++){this.data[x][y]=color}}}}
class CannyEdgeDetection{gaussianBlur(imgData,sigmma=1.4,size=3){let kernel=this.generateKernel(sigmma,size);let copy=imgData.copy();copy.fill(0);imgData.eachPixel(size,function(x,y,current,neighbors){let i=0;let _size=size-1;while(i<=_size){let j=0;while(j<=_size){copy.data[x][y]+=neighbors[i][j]*kernel[i][j];j++}
i++}});return copy}
generateKernel(sigmma,size){let s=sigmma;let e=2.718;let kernel=Util.generateMatrix(size,size,0);let sum=0;for(let i=0,_size=size-1;i<_size;i++){let x=-(size-1)/2+i;for(let j=0;j<_size;j++){let y=-(size-1)/2+j;let gaussian=(1/(2*Math.PI*s*s))*Math.pow(e,-(x*x+y*y)/(2*s*s));kernel[i][j]=gaussian;sum+=gaussian}}
for(let i=0,_size=size-1;i<_size;i++){for(let j=0;j<_size;j++){kernel[i][j]=(kernel[i][j]/sum).toFixed(3)}}
return kernel}
sobel(imgData){let yFiler=[[-1,0,1],[-2,0,2],[-1,0,1]];let xFiler=[[-1,-2,-1],[0,0,0],[1,2,1]];let copy=imgData.copy();copy.fill(0);imgData.eachPixel(3,function(x,y,current,neighbors){let ghs=0;let gvs=0;for(let i=0;i<=2;i++){for(let j=0;j<=2;j++){ghs+=yFiler[i][j]*neighbors[i][j];gvs+=xFiler[i][j]*neighbors[i][j]}}
copy.data[x][y]=Math.sqrt(ghs*ghs+gvs*gvs)});return copy}
nonMaximumSuppression(imgData){let copy=imgData.copy();copy.fill(0);imgData.eachPixel(3,function(x,y,c,n){if(n[1][1]>n[0][1]&&n[1][1]>n[2][1]){copy.data[x][y]=n[1][1]}else{copy.data[x][y]=0}
if(n[1][1]>n[0][2]&&n[1][1]>n[2][0]){copy.data[x][y]=n[1][1]}else{copy.data[x][y]=0}
if(n[1][1]>n[1][0]&&n[1][1]>n[1][2]){copy.data[x][y]=n[1][1]}else{copy.data[x][y]=0}
if(n[1][1]>n[0][0]&&n[1][1]>n[2][2]){return copy.data[x][y]=n[1][1]}else{return copy.data[x][y]=0}});return copy}
hysteresis(imgData,ht,lt){let copy=imgData.copy();let isStrong=function(edge){return edge>ht};let isCandidate=function(edge){return edge<=ht&&edge>=lt};let isWeak=function(edge){return edge<lt};imgData.eachPixel(3,function(x,y,current,neighbors){if(isStrong(current)){return copy.data[x][y]=255}else if(isWeak(current)||isCandidate(current)){return copy.data[x][y]=0}});let traverseEdge=function(x,y){if(x===0||y===0||x===imgData.width-1||y===imgData.height-1){return}
if(isStrong(copy.data[x][y])){let neighbors=copy.getNeighbors(x,y,3);for(let i=0;i<=2;i++){for(let j=0;j<=2;j++){if(isCandidate(neighbors[i][j])){copy.data[x-1+i][y-1+j]=255;traverseEdge(x-1+i,y-1+j)}}}}};copy.eachPixel(3,function(x,y){return traverseEdge(x,y)});copy.eachPixel(1,function(x,y,current){if(!isStrong(current)){return copy.data[x][y]=0}});return copy}
canny(canvas,ht,lt,sigmma,kernelSize){let imgData=new GrayImageData(canvas.width,canvas.height);imgData.loadCanvas(canvas);let blur=this.gaussianBlur(imgData,sigmma,kernelSize);let sobel=this.sobel(blur);let nms=this.nonMaximumSuppression(sobel);return this.hysteresis(nms,ht,lt)}
cannyWorker(canvasWidth,canvasHeight,canvasRawDate,ht,lt,sigmma,kernelSize){let imgData=new GrayImageData(canvasWidth,canvasHeight);imgData.loadCanvasFromData(canvasRawDate);let blur=this.gaussianBlur(imgData,sigmma,kernelSize);let sobel=this.sobel(blur);let nms=this.nonMaximumSuppression(sobel);return this.hysteresis(nms,ht,lt)}}
